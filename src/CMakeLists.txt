IF(DEBUG_POOL)
	SET(GIT_DEBUG_POOL 1)
ENDIF()
ADD_FEATURE_INFO(debugpool GIT_DEBUG_POOL "debug pool allocator")

# This variable will contain the libraries we need to put into
# libgit2.pc's Requires.private. That is, what we're linking to or
# what someone who's statically linking us needs to link to.
SET(LIBGIT2_PC_REQUIRES "")
# This will be set later if we use the system's http-parser library or
# use iconv (OSX) and will be written to the Libs.private field in the
# pc file.
SET(LIBGIT2_PC_LIBS "")

SET(LIBGIT2_INCLUDES
	"${CMAKE_CURRENT_BINARY_DIR}"
	"${libgit2_SOURCE_DIR}/src"
	"${libgit2_SOURCE_DIR}/include")
SET(LIBGIT2_SYSTEM_INCLUDES "")
SET(LIBGIT2_LIBS "")

# Installation paths
#
SET(BIN_INSTALL_DIR bin CACHE PATH "Where to install binaries to.")
SET(LIB_INSTALL_DIR lib CACHE PATH "Where to install libraries to.")
SET(INCLUDE_INSTALL_DIR include CACHE PATH "Where to install headers to.")

# Set a couple variables to be substituted inside the .pc file.
# We can't just use LIB_INSTALL_DIR in the .pc file, as passing them as absolue
# or relative paths is both valid and supported by cmake.
SET (PKGCONFIG_PREFIX ${CMAKE_INSTALL_PREFIX})

IF(IS_ABSOLUTE ${LIB_INSTALL_DIR})
  SET (PKGCONFIG_LIBDIR ${LIB_INSTALL_DIR})
ELSE(IS_ABSOLUTE ${LIB_INSTALL_DIR})
  SET (PKGCONFIG_LIBDIR "\${prefix}/${LIB_INSTALL_DIR}")
ENDIF (IS_ABSOLUTE ${LIB_INSTALL_DIR})

IF(IS_ABSOLUTE ${INCLUDE_INSTALL_DIR})
  SET (PKGCONFIG_INCLUDEDIR ${INCLUDE_INSTALL_DIR})
ELSE(IS_ABSOLUTE ${INCLUDE_INSTALL_DIR})
  SET (PKGCONFIG_INCLUDEDIR "\${prefix}/${INCLUDE_INSTALL_DIR}")
ENDIF(IS_ABSOLUTE ${INCLUDE_INSTALL_DIR})

# Enable tracing
IF (ENABLE_TRACE STREQUAL "ON")
	SET(GIT_TRACE 1)
ENDIF()
ADD_FEATURE_INFO(tracing GIT_TRACE "tracing support")

CHECK_SYMBOL_EXISTS(regcomp_l "regex.h;xlocale.h" HAVE_REGCOMP_L)
IF (HAVE_REGCOMP_L)
	SET(GIT_USE_REGCOMP_L 1)
ENDIF ()

CHECK_FUNCTION_EXISTS(futimens HAVE_FUTIMENS)
IF (HAVE_FUTIMENS)
	SET(GIT_USE_FUTIMENS 1)
ENDIF ()

CHECK_PROTOTYPE_DEFINITION(qsort_r
	"void qsort_r(void *base, size_t nmemb, size_t size, void *thunk, int (*compar)(void *, const void *, const void *))"
	"" "stdlib.h" HAVE_QSORT_R_BSD)
IF (HAVE_QSORT_R_BSD)
	ADD_DEFINITIONS(-DHAVE_QSORT_R_BSD)
ENDIF()

CHECK_PROTOTYPE_DEFINITION(qsort_r
	"void qsort_r(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *, void *), void *arg)"
	"" "stdlib.h" HAVE_QSORT_R_GNU)
IF (HAVE_QSORT_R_GNU)
	ADD_DEFINITIONS(-DHAVE_QSORT_R_GNU)
ENDIF()

CHECK_FUNCTION_EXISTS(qsort_s HAVE_QSORT_S)
IF (HAVE_QSORT_S)
	ADD_DEFINITIONS(-DHAVE_QSORT_S)
ENDIF ()

# Find required dependencies

IF(WIN32)
	LIST(APPEND LIBGIT2_LIBS ws2_32)
ELSEIF(CMAKE_SYSTEM_NAME MATCHES "(Solaris|SunOS)")
	LIST(APPEND LIBGIT2_LIBS socket nsl)
	LIST(APPEND LIBGIT2_PC_LIBS "-lsocket" "-lnsl")
ELSEIF(CMAKE_SYSTEM_NAME MATCHES "Haiku")
	LIST(APPEND LIBGIT2_LIBS network)
	LIST(APPEND LIBGIT2_PC_LIBS "-lnetwork")
ENDIF()

CHECK_LIBRARY_EXISTS(rt clock_gettime "time.h" NEED_LIBRT)
IF(NEED_LIBRT)
	LIST(APPEND LIBGIT2_LIBS rt)
	LIST(APPEND LIBGIT2_PC_LIBS "-lrt")
ENDIF()

IF(THREADSAFE)
	LIST(APPEND LIBGIT2_LIBS ${CMAKE_THREAD_LIBS_INIT})
	LIST(APPEND LIBGIT2_PC_LIBS ${CMAKE_THREAD_LIBS_INIT})
ENDIF()
ADD_FEATURE_INFO(threadsafe THREADSAFE "threadsafe support")


IF (WIN32 AND EMBED_SSH_PATH)
	FILE(GLOB SRC_SSH "${EMBED_SSH_PATH}/src/*.c")
	LIST(APPEND LIBGIT2_SYSTEM_INCLUDES "${EMBED_SSH_PATH}/include")
	FILE(WRITE "${EMBED_SSH_PATH}/src/libssh2_config.h" "#define HAVE_WINCNG\n#define LIBSSH2_WINCNG\n#include \"../win32/libssh2_config.h\"")
	SET(GIT_SSH 1)
ENDIF()

IF (WIN32 AND WINHTTP)
	SET(GIT_WINHTTP 1)

	# Since MinGW does not come with headers or an import library for winhttp,
	# we have to include a private header and generate our own import library
	IF (MINGW)
		ADD_SUBDIRECTORY("${libgit2_SOURCE_DIR}/deps/winhttp" "${libgit2_BINARY_DIR}/deps/winhttp")
		LIST(APPEND LIBGIT2_LIBS winhttp)
		LIST(APPEND LIBGIT2_SYSTEM_INCLUDES "${libgit2_SOURCE_DIR}/deps/winhttp")
	ELSE()
		LIST(APPEND LIBGIT2_LIBS "winhttp")
		LIST(APPEND LIBGIT2_PC_LIBS "-lwinhttp")
	ENDIF ()

	LIST(APPEND LIBGIT2_LIBS "rpcrt4" "crypt32" "ole32")
	LIST(APPEND LIBGIT2_PC_LIBS "-lrpcrt4" "-lcrypt32" "-lole32")
ENDIF()

IF (USE_HTTPS)
	# We try to find any packages our backends might use
	FIND_PACKAGE(OpenSSL)
	FIND_PACKAGE(mbedTLS)
	IF (CMAKE_SYSTEM_NAME MATCHES "Darwin")
		FIND_PACKAGE(Security)
		FIND_PACKAGE(CoreFoundation)
	ENDIF()

	# Auto-select TLS backend
	IF (USE_HTTPS STREQUAL ON)
		IF (SECURITY_FOUND)
			IF (SECURITY_HAS_SSLCREATECONTEXT)
				SET(HTTPS_BACKEND "SecureTransport")
			ELSE()
				MESSAGE("-- Security framework is too old, falling back to OpenSSL")
				SET(HTTPS_BACKEND "OpenSSL")
			ENDIF()
		ELSEIF (WINHTTP)
			SET(HTTPS_BACKEND "WinHTTP")
		ELSEIF(OPENSSL_FOUND)
			SET(HTTPS_BACKEND "OpenSSL")
		ELSEIF(MBEDTLS_FOUND)
			SET(HTTPS_BACKEND "mbedTLS")
		ELSE()
			MESSAGE(FATAL_ERROR "Unable to autodetect a usable HTTPS backend."
				"Please pass the backend name explicitly (-DUSE_HTTPS=backend)")
		ENDIF()
	ELSE()
		# Backend was explicitly set
		SET(HTTPS_BACKEND ${USE_HTTPS})
	ENDIF()

	# Check that we can find what's required for the selected backend
	IF (HTTPS_BACKEND STREQUAL "SecureTransport")
		IF (NOT COREFOUNDATION_FOUND)
			MESSAGE(FATAL_ERROR "Cannot use SecureTransport backend, CoreFoundation.framework not found")
		ENDIF()
		IF (NOT SECURITY_FOUND)
			MESSAGE(FATAL_ERROR "Cannot use SecureTransport backend, Security.framework not found")
		ENDIF()
		IF (NOT SECURITY_HAS_SSLCREATECONTEXT)
			MESSAGE(FATAL_ERROR "Cannot use SecureTransport backend, SSLCreateContext not supported")
		ENDIF()

		SET(GIT_SECURE_TRANSPORT 1)
		LIST(APPEND LIBGIT2_SYSTEM_INCLUDES ${SECURITY_INCLUDE_DIR})
		LIST(APPEND LIBGIT2_LIBS ${COREFOUNDATION_LIBRARIES} ${SECURITY_LIBRARIES})
		LIST(APPEND LIBGIT2_PC_LIBS ${COREFOUNDATION_LDFLAGS} ${SECURITY_LDFLAGS})
	ELSEIF (HTTPS_BACKEND STREQUAL "OpenSSL")
		IF (NOT OPENSSL_FOUND)
			MESSAGE(FATAL_ERROR "Asked for OpenSSL TLS backend, but it wasn't found")
		ENDIF()

		SET(GIT_OPENSSL 1)
		LIST(APPEND LIBGIT2_SYSTEM_INCLUDES ${OPENSSL_INCLUDE_DIR})
		LIST(APPEND LIBGIT2_LIBS ${OPENSSL_LIBRARIES})
		LIST(APPEND LIBGIT2_PC_LIBS ${OPENSSL_LDFLAGS})
		LIST(APPEND LIBGIT2_PC_REQUIRES "openssl")
	ELSEIF(HTTPS_BACKEND STREQUAL "mbedTLS")
		IF (NOT MBEDTLS_FOUND)
			MESSAGE(FATAL_ERROR "Asked for mbedTLS backend, but it wasn't found")
		ENDIF()

		IF(NOT CERT_LOCATION)
			MESSAGE("Auto-detecting default certificates location")
			IF(CMAKE_SYSTEM_NAME MATCHES Darwin)
				# Check for an Homebrew installation
				SET(OPENSSL_CMD "/usr/local/opt/openssl/bin/openssl")
			ELSE()
				SET(OPENSSL_CMD "openssl")
			ENDIF()
			EXECUTE_PROCESS(COMMAND ${OPENSSL_CMD} version -d OUTPUT_VARIABLE OPENSSL_DIR OUTPUT_STRIP_TRAILING_WHITESPACE)
			IF(OPENSSL_DIR)
				STRING(REGEX REPLACE "^OPENSSLDIR: \"(.*)\"$" "\\1/" OPENSSL_DIR ${OPENSSL_DIR})

				SET(OPENSSL_CA_LOCATIONS
					"ca-bundle.pem"             # OpenSUSE Leap 42.1
					"cert.pem"                  # Ubuntu 14.04, FreeBSD
					"certs/ca-certificates.crt" # Ubuntu 16.04
					"certs/ca.pem"              # Debian 7
				)
				FOREACH(SUFFIX IN LISTS OPENSSL_CA_LOCATIONS)
					SET(LOC "${OPENSSL_DIR}${SUFFIX}")
					IF(NOT CERT_LOCATION AND EXISTS "${OPENSSL_DIR}${SUFFIX}")
						SET(CERT_LOCATION ${LOC})
					ENDIF()
				ENDFOREACH()
			ELSE()
				MESSAGE("Unable to find OpenSSL executable. Please provide default certificate location via CERT_LOCATION")
			ENDIF()
		ENDIF()

		IF(CERT_LOCATION)
			IF(NOT EXISTS ${CERT_LOCATION})
				MESSAGE(FATAL_ERROR "Cannot use CERT_LOCATION=${CERT_LOCATION} as it doesn't exist")
			ENDIF()
			ADD_FEATURE_INFO(CERT_LOCATION ON "using certificates from ${CERT_LOCATION}")
			ADD_DEFINITIONS(-DGIT_DEFAULT_CERT_LOCATION="${CERT_LOCATION}")
		ENDIF()

		SET(GIT_MBEDTLS 1)
		LIST(APPEND LIBGIT2_SYSTEM_INCLUDES ${MBEDTLS_INCLUDE_DIR})
		LIST(APPEND LIBGIT2_LIBS ${MBEDTLS_LIBRARIES})
		# mbedTLS has no pkgconfig file, hence we can't require it
		# https://github.com/ARMmbed/mbedtls/issues/228
		# For now, pass its link flags as our own
		LIST(APPEND LIBGIT2_PC_LIBS ${MBEDTLS_LIBRARIES})
	ELSEIF (HTTPS_BACKEND STREQUAL "WinHTTP")
		# WinHTTP setup was handled in the WinHTTP-specific block above
	ELSE()
		MESSAGE(FATAL_ERROR "Asked for backend ${HTTPS_BACKEND} but it wasn't found")
	ENDIF()

	ADD_FEATURE_INFO(HTTPS ON "using ${HTTPS_BACKEND}")
	SET(GIT_HTTPS 1)
ELSE()
	ADD_FEATURE_INFO(HTTPS OFF "no support")
ENDIF()

# Specify sha1 implementation
IF(SHA1_BACKEND STREQUAL "OpenSSL")
	IF(NOT OPENSSL_FOUND)
		FIND_PACKAGE(OpenSSL)
		IF(NOT OPENSSL_FOUND)
		    MESSAGE(FATAL_ERROR "Requested OpenSSL SHA1 backend, but OpenSSL could not be found")
		ENDIF()
	ENDIF()

	ADD_FEATURE_INFO(SHA ON "using OpenSSL")
	SET(GIT_SHA1_OPENSSL 1)
	IF(CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
		LIST(APPEND LIBGIT2_PC_LIBS "-lssl")
	ELSE()
		LIST(APPEND LIBGIT2_PC_REQUIRES "openssl")
	ENDIF()
ELSEIF(SHA1_BACKEND STREQUAL "CollisionDetection")
	ADD_FEATURE_INFO(SHA ON "using CollisionDetection")
	SET(GIT_SHA1_COLLISIONDETECT 1)
	ADD_DEFINITIONS(-DSHA1DC_NO_STANDARD_INCLUDES=1)
	ADD_DEFINITIONS(-DSHA1DC_CUSTOM_INCLUDE_SHA1_C=\"common.h\")
	ADD_DEFINITIONS(-DSHA1DC_CUSTOM_INCLUDE_UBC_CHECK_C=\"common.h\")
	FILE(GLOB SRC_SHA1 hash/hash_collisiondetect.c hash/sha1dc/*)
ELSEIF(SHA1_BACKEND STREQUAL "Generic")
	ADD_FEATURE_INFO(SHA ON "using Generic")
	FILE(GLOB SRC_SHA1 hash/hash_generic.c)
ELSEIF(SHA1_BACKEND STREQUAL "Win32")
	ADD_FEATURE_INFO(SHA ON "using Win32")
	SET(GIT_SHA1_WIN32 1)
	FILE(GLOB SRC_SHA1 hash/hash_win32.c)
ELSEIF(SHA1_BACKEND STREQUAL "CommonCrypto")
	ADD_FEATURE_INFO(SHA ON "using CommonCrypto")
	SET(GIT_SHA1_COMMON_CRYPTO 1)
ELSEIF (SHA1_BACKEND STREQUAL "mbedTLS")
	ADD_FEATURE_INFO(SHA ON "using mbedTLS")
	SET(GIT_SHA1_MBEDTLS 1)
	FILE(GLOB SRC_SHA1 hash/hash_mbedtls.c)
	LIST(APPEND LIBGIT2_SYSTEM_INCLUDES ${MBEDTLS_INCLUDE_DIR})
	LIST(APPEND LIBGIT2_LIBS ${MBEDTLS_LIBRARIES})
	# mbedTLS has no pkgconfig file, hence we can't require it
	# https://github.com/ARMmbed/mbedtls/issues/228
	# For now, pass its link flags as our own
	LIST(APPEND LIBGIT2_PC_LIBS ${MBEDTLS_LIBRARIES})
ELSE()
	MESSAGE(FATAL_ERROR "Asked for unknown SHA1 backend ${SHA1_BACKEND}")
ENDIF()

# Include POSIX regex when it is required
IF(WIN32 OR AMIGA OR CMAKE_SYSTEM_NAME MATCHES "(Solaris|SunOS)")
	ADD_SUBDIRECTORY("${libgit2_SOURCE_DIR}/deps/regex" "${libgit2_BINARY_DIR}/deps/regex")
	LIST(APPEND LIBGIT2_SYSTEM_INCLUDES "${libgit2_SOURCE_DIR}/deps/regex")
	LIST(APPEND LIBGIT2_OBJECTS $<TARGET_OBJECTS:regex>)
ENDIF()

# Optional external dependency: http-parser
FIND_PACKAGE(HTTP_Parser)
IF (USE_EXT_HTTP_PARSER AND HTTP_PARSER_FOUND AND HTTP_PARSER_VERSION_MAJOR EQUAL 2)
	LIST(APPEND LIBGIT2_SYSTEM_INCLUDES ${HTTP_PARSER_INCLUDE_DIRS})
	LIST(APPEND LIBGIT2_LIBS ${HTTP_PARSER_LIBRARIES})
	LIST(APPEND LIBGIT2_PC_LIBS "-lhttp_parser")
	ADD_FEATURE_INFO(http-parser ON "http-parser support")
ELSE()
	MESSAGE(STATUS "http-parser version 2 was not found or disabled; using bundled 3rd-party sources.")
	ADD_SUBDIRECTORY("${libgit2_SOURCE_DIR}/deps/http-parser" "${libgit2_BINARY_DIR}/deps/http-parser")
	LIST(APPEND LIBGIT2_SYSTEM_INCLUDES "${libgit2_SOURCE_DIR}/deps/http-parser")
	LIST(APPEND LIBGIT2_OBJECTS "$<TARGET_OBJECTS:http-parser>")
	ADD_FEATURE_INFO(http-parser ON "http-parser support (bundled)")
ENDIF()

# Optional external dependency: zlib
IF(NOT USE_BUNDLED_ZLIB)
	FIND_PACKAGE(ZLIB)
	IF(ZLIB_FOUND)
		LIST(APPEND LIBGIT2_SYSTEM_INCLUDES ${ZLIB_INCLUDE_DIRS})
		LIST(APPEND LIBGIT2_LIBS ${ZLIB_LIBRARIES})
		IF(APPLE OR CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
			LIST(APPEND LIBGIT2_LIBS "z")
			LIST(APPEND LIBGIT2_PC_LIBS "-lz")
		ELSE()
			LIST(APPEND LIBGIT2_PC_REQUIRES "zlib")
		ENDIF()
		ADD_FEATURE_INFO(zlib ON "using system zlib")
	ELSE()
		MESSAGE(STATUS "zlib was not found; using bundled 3rd-party sources." )
	ENDIF()
ENDIF()
IF(USE_BUNDLED_ZLIB OR NOT ZLIB_FOUND)
	ADD_SUBDIRECTORY("${libgit2_SOURCE_DIR}/deps/zlib" "${libgit2_BINARY_DIR}/deps/zlib")
	LIST(APPEND LIBGIT2_SYSTEM_INCLUDES "${libgit2_SOURCE_DIR}/deps/zlib")
	LIST(APPEND LIBGIT2_OBJECTS $<TARGET_OBJECTS:zlib>)
	ADD_FEATURE_INFO(zlib ON "using bundled zlib")
ENDIF()

# Optional external dependency: libssh2
IF (USE_SSH)
	FIND_PKGLIBRARIES(LIBSSH2 libssh2)
ENDIF()
IF (LIBSSH2_FOUND)
	SET(GIT_SSH 1)
	LIST(APPEND LIBGIT2_SYSTEM_INCLUDES ${LIBSSH2_INCLUDE_DIRS})
	LIST(APPEND LIBGIT2_LIBS ${LIBSSH2_LIBRARIES})
	LIST(APPEND LIBGIT2_PC_LIBS ${LIBSSH2_LDFLAGS})

	CHECK_LIBRARY_EXISTS("${LIBSSH2_LIBRARIES}" libssh2_userauth_publickey_frommemory "${LIBSSH2_LIBRARY_DIRS}" HAVE_LIBSSH2_MEMORY_CREDENTIALS)
	IF (HAVE_LIBSSH2_MEMORY_CREDENTIALS)
		SET(GIT_SSH_MEMORY_CREDENTIALS 1)
	ENDIF()
ELSE()
	MESSAGE(STATUS "LIBSSH2 not found. Set CMAKE_PREFIX_PATH if it is installed outside of the default search path.")
ENDIF()
ADD_FEATURE_INFO(SSH GIT_SSH "SSH transport support")

# Optional external dependency: libgssapi
IF (USE_GSSAPI)
	FIND_PACKAGE(GSSAPI)
ENDIF()
IF (GSSAPI_FOUND)
	SET(GIT_GSSAPI 1)
	LIST(APPEND LIBGIT2_LIBS ${GSSAPI_LIBRARIES})
ENDIF()
ADD_FEATURE_INFO(SPNEGO GIT_GSSAPI "SPNEGO authentication support")

# Optional external dependency: iconv
IF (USE_ICONV)
	FIND_PACKAGE(Iconv)
ENDIF()
IF (ICONV_FOUND)
	SET(GIT_USE_ICONV 1)
	LIST(APPEND LIBGIT2_SYSTEM_INCLUDES ${ICONV_INCLUDE_DIR})
	LIST(APPEND LIBGIT2_LIBS ${ICONV_LIBRARIES})
	LIST(APPEND LIBGIT2_PC_LIBS ${ICONV_LIBRARIES})
ENDIF()
ADD_FEATURE_INFO(iconv GIT_USE_ICONV "iconv encoding conversion support")


IF (THREADSAFE)
	IF (NOT WIN32)
		FIND_PACKAGE(Threads REQUIRED)
	ENDIF()

	SET(GIT_THREADS 1)
ENDIF()

IF (USE_NSEC)
	SET(GIT_USE_NSEC 1)
ENDIF()

IF (HAVE_STRUCT_STAT_ST_MTIM)
	SET(GIT_USE_STAT_MTIM 1)
ELSEIF (HAVE_STRUCT_STAT_ST_MTIMESPEC)
	SET(GIT_USE_STAT_MTIMESPEC 1)
ELSEIF (HAVE_STRUCT_STAT_ST_MTIME_NSEC)
	SET(GIT_USE_STAT_MTIME_NSEC 1)
ENDIF()

ADD_DEFINITIONS(-D_FILE_OFFSET_BITS=64)

# Collect sourcefiles
FILE(GLOB SRC_H
	"${libgit2_SOURCE_DIR}/include/git2.h"
	"${libgit2_SOURCE_DIR}/include/git2/*.h"
	"${libgit2_SOURCE_DIR}/include/git2/sys/*.h")

# On Windows use specific platform sources
IF (WIN32 AND NOT CYGWIN)
	ADD_DEFINITIONS(-DWIN32 -D_WIN32_WINNT=0x0600)

	IF(MSVC)
		SET(WIN_RC "win32/git2.rc")
	ENDIF()

	FILE(GLOB SRC_OS win32/*.c win32/*.h)
ELSEIF (AMIGA)
	ADD_DEFINITIONS(-DNO_ADDRINFO -DNO_READDIR_R -DNO_MMAP)
ELSE()
	IF (VALGRIND)
		ADD_DEFINITIONS(-DNO_MMAP)
	ENDIF()
	FILE(GLOB SRC_OS unix/*.c unix/*.h)
ENDIF()
FILE(GLOB SRC_GIT2 *.c *.h
	streams/*.c streams/*.h
	transports/*.c transports/*.h
	xdiff/*.c xdiff/*.h)

# Determine architecture of the machine
IF (CMAKE_SIZEOF_VOID_P EQUAL 8)
	SET(GIT_ARCH_64 1)
ELSEIF (CMAKE_SIZEOF_VOID_P EQUAL 4)
	SET(GIT_ARCH_32 1)
ELSEIF (CMAKE_SIZEOF_VOID_P)
	MESSAGE(FATAL_ERROR "Unsupported architecture (pointer size is ${CMAKE_SIZEOF_VOID_P} bytes)")
ELSE()
	MESSAGE(FATAL_ERROR "Unsupported architecture (CMAKE_SIZEOF_VOID_P is unset)")
ENDIF()

CONFIGURE_FILE(features.h.in git2/sys/features.h)

SET(LIBGIT2_SOURCES ${SRC_H} ${SRC_GIT2} ${SRC_OS} ${SRC_SSH} ${SRC_SHA1})

ADD_LIBRARY(git2internal OBJECT ${LIBGIT2_SOURCES})
SET_TARGET_PROPERTIES(git2internal PROPERTIES C_STANDARD 90)
IDE_SPLIT_SOURCES(git2internal)
LIST(APPEND LIBGIT2_OBJECTS $<TARGET_OBJECTS:git2internal>)

IF (${CMAKE_VERSION} VERSION_LESS 2.8.12)
	INCLUDE_DIRECTORIES(${LIBGIT2_INCLUDES})
	INCLUDE_DIRECTORIES(SYSTEM ${LIBGIT2_SYSTEM_INCLUDES})
ELSE()
	TARGET_INCLUDE_DIRECTORIES(git2internal
	    PRIVATE ${LIBGIT2_INCLUDES}
	    PUBLIC ${libgit2_SOURCE_DIR}/include)
	TARGET_INCLUDE_DIRECTORIES(git2internal
	    SYSTEM PRIVATE ${LIBGIT2_SYSTEM_INCLUDES})
ENDIF()

SET(LIBGIT2_OBJECTS ${LIBGIT2_OBJECTS} PARENT_SCOPE)
SET(LIBGIT2_INCLUDES ${LIBGIT2_INCLUDES} PARENT_SCOPE)
SET(LIBGIT2_SYSTEM_INCLUDES ${LIBGIT2_SYSTEM_INCLUDES} PARENT_SCOPE)
SET(LIBGIT2_LIBS ${LIBGIT2_LIBS} PARENT_SCOPE)

IF(XCODE_VERSION)
	# This is required for Xcode to actually link the libgit2 library
	# when using only object libraries.
	FILE(WRITE ${CMAKE_CURRENT_BINARY_DIR}/dummy.c "")
	LIST(APPEND LIBGIT2_OBJECTS ${CMAKE_CURRENT_BINARY_DIR}/dummy.c)
ENDIF()

# Compile and link libgit2
ADD_LIBRARY(git2 ${WIN_RC} ${LIBGIT2_OBJECTS})
TARGET_LINK_LIBRARIES(git2 ${LIBGIT2_LIBS})

SET_TARGET_PROPERTIES(git2 PROPERTIES C_STANDARD 90)
SET_TARGET_PROPERTIES(git2 PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${libgit2_BINARY_DIR})
SET_TARGET_PROPERTIES(git2 PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${libgit2_BINARY_DIR})
SET_TARGET_PROPERTIES(git2 PROPERTIES ARCHIVE_OUTPUT_DIRECTORY ${libgit2_BINARY_DIR})

# Workaround for Cmake bug #0011240 (see http://public.kitware.com/Bug/view.php?id=11240)
# Win64+MSVC+static libs = linker error
IF(MSVC AND GIT_ARCH_64 AND NOT BUILD_SHARED_LIBS)
  SET_TARGET_PROPERTIES(git2 PROPERTIES STATIC_LIBRARY_FLAGS "/MACHINE:x64")
ENDIF()

IDE_SPLIT_SOURCES(git2)

IF (SONAME)
	SET_TARGET_PROPERTIES(git2 PROPERTIES VERSION ${LIBGIT2_VERSION_STRING})
	SET_TARGET_PROPERTIES(git2 PROPERTIES SOVERSION ${LIBGIT2_SOVERSION})
	IF (LIBGIT2_FILENAME)
		ADD_DEFINITIONS(-DLIBGIT2_FILENAME=\"${LIBGIT2_FILENAME}\")
		SET_TARGET_PROPERTIES(git2 PROPERTIES OUTPUT_NAME ${LIBGIT2_FILENAME})
	ELSEIF (DEFINED LIBGIT2_PREFIX)
		SET_TARGET_PROPERTIES(git2 PROPERTIES PREFIX "${LIBGIT2_PREFIX}")
	ENDIF()
ENDIF()

LIST(REMOVE_DUPLICATES LIBGIT2_PC_REQUIRES)
STRING(REPLACE ";" " " LIBGIT2_PC_REQUIRES "${LIBGIT2_PC_REQUIRES}")
STRING(REPLACE ";" " " LIBGIT2_PC_LIBS "${LIBGIT2_PC_LIBS}")
CONFIGURE_FILE(${libgit2_SOURCE_DIR}/libgit2.pc.in ${libgit2_BINARY_DIR}/libgit2.pc @ONLY)

IF (MSVC_IDE)
   # Precompiled headers
   SET_TARGET_PROPERTIES(git2 PROPERTIES COMPILE_FLAGS "/Yuprecompiled.h /FIprecompiled.h")
   SET_SOURCE_FILES_PROPERTIES(win32/precompiled.c COMPILE_FLAGS "/Ycprecompiled.h")
ENDIF ()

# Install
INSTALL(TARGETS git2
	RUNTIME DESTINATION ${BIN_INSTALL_DIR}
	LIBRARY DESTINATION ${LIB_INSTALL_DIR}
	ARCHIVE DESTINATION ${LIB_INSTALL_DIR}
)
INSTALL(FILES ${libgit2_BINARY_DIR}/libgit2.pc DESTINATION ${LIB_INSTALL_DIR}/pkgconfig )
INSTALL(DIRECTORY ${libgit2_SOURCE_DIR}/include/git2 DESTINATION ${INCLUDE_INSTALL_DIR} )
INSTALL(FILES ${libgit2_SOURCE_DIR}/include/git2.h DESTINATION ${INCLUDE_INSTALL_DIR} )
